I"í<p>No dia 10 de julho de 2020, estava eu calmamente navegando pela minha timeline do Twiter, quando me aparece o tweet abaixo:</p>

<div>
<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Made myself a self-updating GitHub personal README! It uses a GitHub Action to update itself with my latest GitHub releases, blog entries and TILs <a href="https://t.co/Eve7FOrwYK">https://t.co/Eve7FOrwYK</a> <a href="https://t.co/oJPXLtFdgM">pic.twitter.com/oJPXLtFdgM</a></p>&mdash; Simon Willison (@simonw) <a href="https://twitter.com/simonw/status/1281435464474324993?ref_src=twsrc%5Etfw">July 10, 2020</a></blockquote> <script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
</div>

<p>Para um desenvolvedor sua exist√™ncia j√° est√° resumida na pr√≥pria bio do GitHub, na p√°gina <a href="https://nymarya.github.io">about</a> do site pessoal, na descri√ß√£o do LinkedIn, √†s vezes at√© na descri√ß√£o do Twitter, e com a possibilidade de automatizar. Depois da inven√ß√£o do Simon, a feature nova pareceu mais interessante, podendo dar um diferencial em rela√ß√£o √†s outras de poder trazer informa√ß√µes sintetizadas que n√£o precisam ser ajustadas manualmente (e consequentemente esquecidas de serem atualizadas).</p>

<h3 id="come√ßando-a-automatiza√ß√£o-readme">Come√ßando a automatiza√ß√£o README</h3>

<p>O primeiro passo √© escolher quais informa√ß√µes devem aparecer. No meu caso, queria mostrar os posts e um resumo do que tem no meu GitHub, as linguagens que est√£o presentes nele.</p>

<p>O pr√≥prio resumo escolhi escrever manualmente por motivos de: queria usar emoticons; queria escrever em ingl√™s e portugu√™s; algumas informa√ß√µes s√£o pessoais, como os hobbies, e n√£o encontraria lugares de onde tirar a informa√ß√£o; e at√© poderia criar um script que simplemente acrescenta o texto que eu escolhi, mas n√£o acho que ficaria um c√≥digo bonito e organizado.</p>

<p>Pensado isso, √© hora de colocar a m√£o no c√≥digo.</p>

<h3 id="inserindo-posts-com-beautifulsoup">Inserindo posts com BeautifulSoup</h3>

<p>Simon em seu <a href="https://simonwillison.net/2020/Jul/10/self-updating-profile-readme/">post</a> usa uma forma mais robusta e organizada para recuperar os posts, mas infelizmente meu blog no Github Pages n√£o me d√° as mesmas ferramentas. Por√©m, como a estrutura do HTML √© bem organizada, n√£o foi dif√≠cil recuperar o que eu queria.</p>

<p>A biblioteca <a href="https://pypi.org/project/beautifulsoup4/">BeautifulSoup</a> √© √≥tima para minerar informa√ß√µes de sites. Para pegar os posts separados por cada l√≠ngua, recuperei o HTML da <a href="https://nymarya.github.io/categories">p√°gina</a> onde os posts j√° est√£o divididos, identifiquei onde fica cada categoria, e simplemente salvei o endere√ßo, t√≠tulo e data do n√∫mero de links que eu queria. O c√≥digo todo, que tem aproximadamente 30 linhas) est√° <a href="https://github.com/nymarya/nymarya/blob/master/posts.py">aqui</a>.</p>

<h3 id="inserindo-resumo-das-linguagens">Inserindo resumo das linguagens</h3>

<p>Mais uma vez, Simon utilizou uma forma um pouco mais elegante. Dessa vez, foi usando a API em GraphQl para recuperar informa√ß√µes do GitHub.</p>

<p>Resolvi usar a API REST pela praticidade. Usei ela duas vezes: uma para recuperar os nomes dos reposit√≥rios (<code class="language-plaintext highlighter-rouge">https://api.github.com/users/&lt;usuario&gt;/repos</code>) e outra para recuperar as linguagens em cada reposit√≥rio (<code class="language-plaintext highlighter-rouge">https://api.github.com/repos/&lt;usuario&gt;/&lt;repo&gt;/languages'</code>). A vers√£o sem autentica√ß√£o da API, al√©m de acessar s√≥ os reposit√≥rios p√∫blicos, tem um limite de 60 requisi√ß√µes por hora, ent√£o para quem possui 60 reposit√≥rios p√∫blicos ou mais o recomendado √© usar autentica√ß√£o. Todas elas s√£o consultadas utilizando a biblioteca requests.</p>

<p>A resposta da segunda API consiste em um dicion√°rio com cada linguagem e sua contagem de bytes. Assim, para saber a propor√ß√£o basta ir unindo essas informa√ß√µes e no final calcular as porcentagens. Para a exibi√ß√£o, √© usada uma tabela onde na primeira linha ficam as logos das ferramentas (boa parte das logos vem desse <a href="https://github.com/abranhe/programming-languages-logos">reposit√≥rio</a> e na segunda os nome e as porcentagem de c√≥digo em que s√£o usadas. O c√≥digo com todas essas fun√ß√µes est√° <a href="https://github.com/nymarya/nymarya/blob/master/repositories.py">aqui</a>.</p>

<h3 id="agora-sim-a-automatiza√ß√£o">Agora sim a automatiza√ß√£o</h3>

<p>Todo o processo de escrita no arquivo √© feita no arquivo <a href="https://github.com/nymarya/nymarya/blob/master/build_readme.py">build_readme.py</a>. Mas para fazer o preenchimento do arquivo primeiro precisamos indicar no README.md aonde os textos v√£o ser colocados. Isso √© feito com coment√°rios no markdown, que marcam as se√ß√µes:</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- &lt;nome da se√ß√£o&gt;</span> starts --&gt;
<span class="c">&lt;!-- &lt;nome da se√ß√£o&gt;</span> ends --&gt;
</code></pre></div></div>

<p>Da√≠, usando a biblioteca <code class="language-plaintext highlighter-rouge">re</code> podemos usar express√µes regulares para identificar esses blocos. A express√£o usada √© <code class="language-plaintext highlighter-rouge">"&lt;!-- &lt;nome da se√ß√£o&gt; starts --&gt;.*&lt;!-- &lt;nome da se√ß√£o&gt; ends --&gt;"</code>. Na hora de inserir o texto, os coment√°rios se mant√©m, para na pr√≥xima atualiza√ß√£o a se√ß√£o poder ser encontrada novamente, e os caracteres <code class="language-plaintext highlighter-rouge">.*</code> s√£o substitu√≠dos pelo conte√∫do de fato, consequentemente tamb√©m reescrevendo o texto anterior.</p>

<p>O passo final √© configurar o workflow no Github Actions. Isso √© feito indo para a aba espec√≠fica, escolhendo ‚Äúset up a workflow yourself‚Äù e ent√£o adicionando os comandos para configurar o Python e o pip, instalar depend√™ncias que est√£o no requeirements.txt, atualizar o README.md e finalmente dar commit no resultado, al√©m de ajustar o cron para que a tarefa rode a cada 1 hora, entre 1:00 e 23:00. Ao salvar o <code class="language-plaintext highlighter-rouge">main.yml</code> que cont√©m as configura√ß√µes na pasta <code class="language-plaintext highlighter-rouge">.github/workflows</code>, o GitHub Actions vai identificar o arquivo. O workflow √© basicamente o mesmo do Simon, a diferen√ßa √© que o dele ainda inclui um comando para pegar vari√°veis de ambiente.</p>

<h3 id="para-quem-tiver-mais-tempo-e-disposi√ß√£o">Para quem tiver mais tempo e disposi√ß√£o</h3>

<p>Existe uma s√©rie de coisas que poderiam ser automatizadas. Os releases mais recentes (como Simon fez), contagem de commits, intera√ß√µes no StackOverflow (n√£o olhei se eles tem API, se n√£o tiverem certamente o BeautifulSoup resolve), trabalho atual e forma√ß√£o do LinkedIn (se tiverem API deve ser paga, ent√£o novamente poderia usar BeautifulSoup), publica√ß√µes no LinkedIn, posts do Medium, v√≠deos ou epis√≥dios de podcasts mais recentes para quem √© desse mundo, e por a√≠ vai.</p>

<p>Ansiosa para ver quais ideias v√£o surgir. At√© mais!</p>

<h2 id="links">Links</h2>

<p><a href="https://simonwillison.net/2020/Jul/10/self-updating-profile-readme/">Post do Simon onde ele explica o que ele fez</a></p>

<p><a href="https://simonwillison.net/2020/Apr/20/self-rewriting-readme/">Outro post do Simon sobre automatiza√ß√£o do README</a></p>
:ET